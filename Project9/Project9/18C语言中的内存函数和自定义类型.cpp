#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include<string.h>//使strlen可以运行
#include<Windows.h>
#include<stdlib.h>



//结构体
//struct Stu
//{
//	char namr[10];
//	int age;
//}*p,s0;//在这里创建的s0被认为是全局变量，p是结构体指针
//
//struct  Stu s1;//在这里创建的s1是全局变量
//
//struct//这个结构体类型没有名称，所以被称作匿名结构体类型 
//{
//	int a;
//	char b;
//}x,c[10];//与该匿名结构体类型相关的变量只能在这里设置
//
//
//struct//如果存在两个成员一模一样的匿名结构体类型，编译器仍然会把他们识别成两个不同的类型
//{//所以可以看到在这里创建的结构体指针y 不能将x的地址赋给它
//	int a;
//	char b;
//}*y;
//
//
//struct Stuplus
//{
//	int number;
//	struct Stu s9;//在结构体中创建一个其他类型的结构体
//	//struct Stuplus s10;//在结构体中创建一个相同的结构体类型，就是结构体的自引用，我们发现这样写是错误的，这样写会无法判断/struct Stuplus s10;的大小
//	
//	struct Stupius* s10;//正确的结构体自引用写法，这样写可以判断其大小就是一个指针类型的大小
//};
//
//int main()
//{
//	int a = 10;
//	struct Stu s2;//局部的结构体变量
//	//p = &a;//可以看到这样赋值会出错，因为p已经被设置为是Stu* 类型的指针 
//	p = &s2;
//	
//	//y = &x;
//	return 0;
//}




//typedef struct node
//{
//	int data;
//	struct node* next;
//	node* next1;
//
//}node;
//
//int main()
//{
//	node s11;
//	struct node s12;//对结构体重命名之后，这样的两种写法都可以创建结构体变量
//
//	return 0;
//}


//typedef struct
//{
//	int data;
//	node* next;
//}node;


//以上关于匿名结构体类型和结构体的自引用的内容不太好演示，总感觉对这部分内容的理解太模糊，之后要再学学





//结构体内存对齐  具体内容如果遗忘就去看自己的截图  这里只进行简单注解
//struct s1
//{
//	char c1;
//	int a;
//	char c2;
//};
//
//struct s2
//{
//	char c1;
//	char c2;
//	int a;
//};
//
//
//struct s3
//{
//	char c1;
//	struct s1 s1;
//	double d;
//};
//
//int main()
//{
//	struct s1 s1 = { 0 };
//	struct s2 s2 = {0};
//	struct s3 s3 = { 0 };
//	printf("%d,%d,%d\n", sizeof(s1), sizeof(s2),sizeof(s3));//结果为12,8,24
//	return 0;
//}


//结构体对齐规则
//1：第一个成员在与结构体变量偏移量为0的地址处
//2：其他成员变量对齐到对齐数的整数倍的地址处

//对齐数：编译器默认的一个对齐数与该成员大小的较小值
//vs中默认的对齐数为8，gcc中没有默认对齐数

//结构体总大小为最大对齐数（每一个成员都有一个对齐数）的的整数倍
//对于嵌套了结构体的情况，嵌套的结构体对齐到自己的成员变量中的最大对齐数的整数倍处，结构体的整体大小就是其最大对齐数（含嵌套结构体的对齐数）的整数倍处



//存在结构体对齐的原因
//1；平台原因，不是所有的硬件平台都能访问任意地址处的任意数据的，某些平台只能在某些地址处取特定类型的数据。否则会抛出异常
//2：性能原因，结构数据（尤其是栈）应该尽可能在自然边界上对齐，原因在于，为了访问未对齐的内存，处理器需要进行两次访问，而访问对齐的数据只需要一次
//比如在32位平台中，如果一次读取32个比特位即四个字节的数据，对于未对齐的一个int类型，需要取两次才能取完，如果对齐了就可以一次取出，效率更高

//总结来说，内存对齐是拿空间换时间的做法


//那么在设计结构体的时候，在对齐的情况下应该尽量节省空间
//具体做法：让占用空间小的成员尽量集中在一起
//比如：
//struct s1
//{
//	char c1;
//	int i;
//	char c2;
//};
//struct s2
//{
//	char c1;
//	char c2;
//	int i;
//};//s2占用的空间就比s1占用的少




//设置默认对齐数
//#pragma pack(1)
//struct s
//{
//	char c1;
//	double d;
//};
//#pragma pack()//在两个pragam范围内将对齐数设置为1，对齐数为1时所有成员都会紧挨着放置
//
//int main()
//{
//	struct s s;
//	printf("%d\n", sizeof(s));//结果：1+8=9
//
//
//	//offsetof不是函数，而是宏 可以用来求出结构体中的成员在内存对齐中相对于起始位置的偏移量
//
//	printf("%d\n", offsetof(struct s, c1));//0
//	printf("%d\n", offsetof(struct s, d));//1   double的偏移量为1明显是因为上面设置对齐数为1造成的
//
//	return 0;
//}




//将结构体作为参数传入函数时最好采用地址传参，不管是为了给结构体成员赋值还是为了节省空间都最好采用地址传参，这一点之前已经提过就不再讲了。




//位段
//位段的声明和结构体是类似的，但有两个不同
//1:位段的成员必须是int unsigned int ，signed int，short，char  等整型家族的成员
//2：位段的成员名后面有一个冒号和一个数字
//比如：
//struct s
//{
//	int a : 2;//后面的数字是用于存储该成员的比特位数  如果明确a中存储的是较小的数，可以这样减少用于存储a的空间
//	int b : 5;
//	int c : 10;
//	int d : 30;//这里的d如果改成大于32的数则会报错，因为大于一个整型的大小
//};
//
//
////位段的内存分配
////位段的空间上是按照需要，以四个字节或者一个字节的方式来开辟的
////位段涉及很多不确定因素，位段是不跨平台的，注重可移植的程序应该避免使用位段
////对于上面创建的s： 先取到一个整型共32个比特位，存储a,b,c后还有15个比特位，但是d需要30个比特位，所以又取到一个整型来存储d，之前剩余的15个比特位是被浪费掉的，d会完全被存储在取到的第二个整型中
//
////验证：
//int main()
//{
//	printf("%d\n", sizeof(s));//结果为8个字节，即两个整型的大小 
//	return 0;
//}






//struct s
//{
//	char a : 3;
//	char b : 4;
//	char c : 5;
//	char d : 4;
//};
//int main()
//{
//	struct s s;
//	s.a = 10;//10转为二进制是1010  但只能存储三个字节 所以存入010
//	s.b = 20;//同理 存入 0100
//	s.c = 3;//3的二进制是11 不够五位 前面补0 存入00011   
//	s.d = 4;//存入0100
//	return 0;
//}
//取出一个字节只够完整存入a和b，所以再取出一个字节存入c，又不够存d所以又取出一个字节存储d
//如果取出的每个字节是从右向左存入内容 那么这三个字节存储的内容是 00100010 00000011 00000100  转为十六进制就是 22 03 04 
//当我们在内存界面&s时 可以发现存储的内容就是22 03 04 所以取出的空间确实是从右向左使用的




//枚举
//enum sex
//{
//	man,
//	woman,
//	secret
//};
//
//enum color
//{
//	red,
//	green = 1,
//	blue=1,
//	grey
//};
//
//#define white 0 //利用define也可以实现让white对应一个值
//
//int main()
//{
//	enum sex s1 = man;
//  //enum sex s1 = a;//只能从上面设定的sex的成员中选取
//	enum sex s2 = woman;
//
//	int a = man;//可以使用默认值给int类型赋值
//	int b = white;
//
//	printf("%d,%d,%d\n", man, woman, secret);//枚举中的每一个成员都有默认的值 
//	printf("%d,%d,%d,%d\n", red, green, blue,grey);//枚举中的每一个成员都有默认的值,该默认值可以自己设定,被设定的了值的成员之后的没有设定值的成员的默认值会紧跟着设定值，比如这里的grey是2就是紧跟着前面被设定为1的blue
//	
//	
//	//虽然成员有默认值，但无法通过该默认值找到对应成员
//	//enum sex o = 0;//这样的写法是错误的
//	
//
//
//	printf("%d\n", sizeof(s1));
//	printf("%d\n", sizeof(s2));//枚举类型的大小都是四个字节，因为他们的默认值都是int类型，可以把他们当做int类型计算大小
//	
//	printf("%d\n", sizeof(color));//
//	printf("%d\n", sizeof(sex));//发现这个的大小也都是4个字节
//
//
//	return 0;
//}



//我们可以使用#define定义常量，为什么非要用枚举？其优点：
//1：增加代码的可读性和可维护性
//2：相比利用define定义的标识符，枚举有类型检查，更加严谨
//3：防止了命名污染（封装）
//4：便于调试
//5：使用方便，一次可以定义多个常量






//联合体，也叫共用体
//union un
//{
//	int i;
//	char c;
//};

//int main()
//{
//	union un u;
//	printf("%d\n", sizeof(un));//结果是4 
//
//	printf("%p\n", &u);
//	printf("%p\n", &(u.i));
//	printf("%p\n", &(u.c));//发现这三个的地址是相同的  
//	//联合体类型中的成员共用一块空间   这里的u中的int占用4个字节，char占用4个字节中的一个
//     
//
//	u.c = 1;
//	u.i = 100;
//
//	printf("%d\n", u.c);//可以发现让u.i=100使得u.c=1被覆盖了，说明二者不能同时存在
//	printf("%d\n", u.i);
//
//
//	//联合体的大小至少是最大成员的大小（至少要能够存储下最大的那个值）
//	//联合体中的成员不能同时存在，比如这里的i和c不能同时使用，因为他们共用了同一块空间
//
//	return 0;
//}




//百度的面试题：判断当前平台是大端存储（数据的低字节的内容放在高地址处，高字节低地址）还是小端存储（数据的低字节的内容放在低地址处，高字节高地址）
//int main()
//{
//
//	//方法一
//	////int a = 0x12345678;//a在大端存储中存储为78 56 34 12    小端中存储为12 34 56 78
//	//int a = 1;//之前是让a=1，看a在内存中的第一个字节是00还是01来判断大小端存储
//	//if (*(char*)&a == 1)
//	//	printf("小端");
//	//else
//	//	printf("大端");
//
//
//	//方法二
//	union un u;
//	u.i = 1;
//	if (u.c == 1)//利用共用空间的特性取出一个字节，通过该字节的内容进行判断 如果是大端a为00 00 00 01 从c的地址取出为00  如果是小段01 00 00 00 从c的地址取出01
//		                                                                     //（但是我没想明白为什么c的空间不管是在大端还是小端中都是在左边的）
//		printf("小端");
//	else
//		printf("大端");
//
//
//	return 0;
//}




//联合体的大小的计算
//联合体的大小至少是最大成员的大小
//当最大成员大小不是最大对齐数的整数倍的时候，就要对齐到最大对齐数的整数倍
//union un
//{
//	int a;//对齐数是4
//	char arr[5];//对于数组的对齐数 比如这里的char arr[5]，要看作五个char c ，所以char arr[5]的对齐数是1而不是5
//	//注意：数组的对齐数就是其元素的对齐数
//};
//
//int main()
//{
//	union un u;//比如这里的u的大小的计算，最大对齐数是4，虽然最大成员的大小是5个字节，但由于5不是最大对齐数的整数倍，所以要对齐到最近的整数倍就是8处，所以这里的大小是8
//	printf("%d\n", sizeof(u));
//
//
//	return 0;
//}





