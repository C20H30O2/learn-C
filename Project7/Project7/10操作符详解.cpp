#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include<string.h>//使strlen可以运行
#include<Windows.h>
#include<stdlib.h>

//int main()
//{//除法和取模
//	int a = 5 / 2;//a=2    两个数字中至少存在一个小数时两数相/的结果才会是小数 再根据接收他的变量类型决定要不要保留小数部分
//	float b = 5 / 2;//b=2.000000
//	double c = 5.0 / 2;//c=2.500000
//	printf("%d", b);//结果为0    在打印的时候 如果变量类型没有填对 那打印结果只能是0 根据打印时填入的变量类型决定有没有小数位的0
//	printf("%f", b);//结果为2.500000  
//	printf("%lf", c);
//
//	//int d=5%2.0  会报错 
//	//int e=5.0%2
//	int d = 5 % 2;//取模只能适用于整数 
//
//
////移位操作符  移动的是二进制位
//	int f = 16;
//	f >> 1;//右移操作符 a的二进制0000000000000000000000000000000000010000（整型占四个字节，一个字节占八个比特位）
//	                           //0000000000000000000000000000000000001000 右移后的f
//	//右移操作符有两种语法1.算术右移 右边多出的一位丢弃 左边补上原符号位 
//	//2.逻辑右移 右边丢弃 左边补0
//	//这里f是正数 左边的符号位本来就是0 看不出差别
//	int g = -1;
//	int h=g >> 1;
//	printf("%d", h);//说明这里的移位方式是算术右移
//
//	//整数的二进制有三种表示形式 源码 反码 补码 正整数的这三种码是相同的 
//	// 对于整数 存储的是它的补码 所以移位操作符移的是补码
//	//-1的源码 100000000000000000000000000000001  
//	//反码 ：源码的符号位不变 其他位取反 11111111111111111111111111111110
//	//补码：反码加一 11111111111111111111111111111111
//	//按f10进入调试 在调试中找到窗口 找到内存 在内存窗口中输入&g 再按f10 让代码往下走 可以看到g的地址下是ff ff ff ff 这是16进制 f=15 15的二进制是1111 
//	//可以知道-1向右移位的结果还是-1
//	return 0;
//}



////注意：移位操作符只能支持整数且不支持移动负数位 如a=1 a>>-1 
//int main()
//{//左移操作符
//	int a = 5;//0000000000000000000000000000101   左移时左边丢弃 右边补0
//	int b = a << 1;
//	printf("%d", b);//10
//	return 0;
//}



//位操作符
//int main()
//{
//	//& 按二进制位与
//	int a = 3;//011   为了方便只写出来后三位
//	int b = 5;//101
//	int c = a & b;//对应的二进制位两个都是1结果才为1 否则为0 所以a&b=001 所以c=1
//	printf("%d", c);
//
//	//| 按位或
//	int d = 3;
//	int e = 5;
//	int f = d | e;//对应的二进制位只要有一个是1 就是1 所以d|e=111  f=7
//	printf("%d", f);
//
//    //^ 按位异或
//	int g = 3;
//	int h = 5;
//	int i = g ^ h;//对应的二进制位相同为0 相异为1 所以g^h=110 i=6
//	printf("%d", i);
//
//	return 0;
//}


//应用场景 比如不用临时变量交换两个数的值 就要用到 ^ 按位异或 这个题目保存在project5的codetest中



//求一个整数在内存中的二进制位中的1的个数
//int main()
//{   //方法一
//	int num = 10;
//	int count = 0;
//
//
//	//while (num)
//	//{
//	//	if (num % 2 == 1)
//	//		count++;
//	//	num = num / 2;
//	//}
//	//printf("%d\n", count);
//
//
//
//	//方法二
//	//for (i=0;i<32;i++)
//	//{
//	//	if (i == ((num >> i) & 1))//使用移位和逻辑与 直接判断相应位上的数字是否为一
//	//	{
//	//		count++;
//	//	}
//	//}
//	//printf("%d\n", count);
//
//
//
//
//	//方法三
//	//int i = 0;
//	//while (num)
//	//{
//	//	count++;
//	//	num = num & (num - 1);
//	//}
//	//printf("%d\n", count);//相比方法二优化了循环次数
//
//
//
//	return 0;
//}




//赋值操作符可以连续使用
//int main()
//{
//	int a = 1;
//	int b = 2;
//	int c = 3;
//	c = b = a + 1;
//	
//	printf("%d  %d", b, c);
//	return 0;
//}


//复合赋值符+= -= /= *= %= >>= <<= &= |= ^=  比如c&=a 等于c=c&a


//单目操作符  ! - + & sizeof  *解引用操作符 -- ++注意前置与后置的不同  (类型)强制转换类型
//int main()
//{
//	int a = 1;
//	int b = 2;
//	char c = 'r';
//	char* p = &c;
//	int arr[10] = { 0 };
//
//
//
//	printf("%d\n", a++);//先引用a再对a执行加加 直接打印出了引用时a的值
//	printf("%d\n", a);//a=2 说明确实对a执行了加加
//	printf("%d\n", ++a);//先加加a再引用
//	printf("%d\n", a);//a=3
//
//	printf("%d\n", sizeof(a));
//	printf("%d\n", sizeof(a = a + 1));//
//	printf("%d\n", a);//a仍然为3 说明上面的sizeof没有将a+1赋给a
//	printf("%d\n", a = a + 1);//执行了赋值
//	printf("%d\n", a);
//
//	printf("%d\n", sizeof(int));
//	printf("%d\n", sizeof a);
//	//printf("%d",sizeof int) //说明a可以去掉括号 但是int不行
//
//
//	int d =(int)1.11 ;//强制类型转换
//
//
//	printf("%d\n", sizeof(c));
//	printf("%d\n", sizeof(char));
//
//	printf("%d\n", sizeof(p));
//	printf("%d\n", sizeof(char*));
//
//	printf("%d\n", sizeof(arr));
//	printf("%d\n", sizeof(int [10]));
//	
//
//	a = 0;//0视作正数 其源码反码补码都为00000000000000000000000000000000 
//	printf("%d\n", ~a);//对a的补码取反得到 1111111111111111111111111111111111111111 
//	                   //         得到他的反码 11111111111111111111111111111110 再得到他的原码0000000000000000000000000000001 这个原码代表的数就是-1
//	//所以这里输出-1
//
//	return 0;
//}




//注意点
//void test1(int arr[])
//{
//	printf("%d\n", sizeof(arr));//注意：作为函数参数传入时 只传入了其第一个元素的地址 所以这里的arr和ch都是地址 其大小和平台有关 在32位平台里大小为四个字节 64位平台则为8个字节
//}
//
//void test2(char ch[])
//{
//	printf("%d\n", sizeof(ch));
//}
//
//int main()
//{
//	int arr[10] = { 0 };
//	char ch[10] = { 0 };
//	printf("%d\n", sizeof(arr));
//	printf("%d\n", sizeof(ch));
//	test1(arr);
//	test2(ch);
//	return 0;
//}




//int main()
//{
//	int a = 11;
//	a = a | (1 >> 2);
//	printf("%d", a);//15
//	a = a & (~(1 >> 2));
//	printf("%d", a);//11
//	return 0;
//}




//
//int main()
//{
//	int a = 0;
//	int b = 5;
//	int c = a && b;//逻辑与
//	printf("%d", c);
//
//	int d = a || b;//逻辑或
//	printf("%d", d);
//	return 0;
//}



//int main()
//{
//	int i = 0, a = 0, b = 2, c = 3, d = 4;
//	i = a++ && ++b && d++;//要注意前置加加 和后置加加的区别   &&从左到右开始 遇到0就停止 不再进行后面的计算
//	//i = a++ || ++b || d++;//||遇到非0就停止 不再进行后面的运算
//	printf("a=%d\n b=%d\n c=%d\n d=%d\n", a, b, c, d);
//	return 0;
//}





//int main()
//{
//	//int a = 0;
//	//int b = 0;
//	//if (a > 5)
//	//	b = 3;
//	//else
//	//	b = -3;
//
//	int a = 0;
//	int b = 0;
//	b = (a > 5 ? 3 : -3);//等效于上面的部分 判断a是否大于5 是则返回3 否则返回-3
//
//	return 0;
//}




//逗号表达式
//使用逗号隔开的多个表达式 从左向右依次执行 整个表达式的结果是最后一个表达式的结果
//int main()
//{
//	int a = 1;
//	int b = 2;
//	int c = (a > b, a = b + 10, a, b = a + 1);
//	int d = 0;
//	printf("%d\n", c);//13
//
//	if (a = b + 1, c = a / 2, d > 0)//因为d=0所以条件为假 不执行
//		printf("hehe\n");
//	return 0;
//}




//逗号表达式使用示例  这里的get_val()和 count_val()都是假设存在的函数
// 
//a = get_val();
//count_val(a);
//while (a > 0)
//{
//	//业务处理
//	a = get_val();
//	count_val(a);
//}
//
////上面的代码可以简化为
//while (a = get_val(), count_val(a), a > 0)
//{
//	//业务处理
//}





//下标引用 函数调用和结构成员

//[]是下标引用操作符  其操作数是一个数组名加一个索引值
//int main()
//{
//	int arr[10];
//	arr[9] = 10;//这里的下标引用操作符的两个操作数是arr和9
//	return 0;
//}


//()是函数调用操作符 接收一个或多个操作数 第一个是函数名 其余的是传递给函数的参数





//结构体
//struct Stu  //创建了一个学生这样一个结构体类型 定义学生的属性有姓名 年龄 学号
//{
//	char name[20];
//	int age;
//	char id[20];//name age id 可以被称作成员名
//};
//
//int main()
//{
//	int a = 10;
//	struct Stu s1={"jack",20,"123456"};//使用struct stu这个类型创建了一个学生对象s1 并初始化
//	printf("%s\n", s1.name);//结构体.成员名
//	printf("%d\n", s1.age);
//	printf("%s\n", s1.id);
//
//	struct Stu* ps = &s1;
//	printf("%s\n", (*ps).name);//另外一种调用方式
//
//	printf("%s\n", ps->name);//又一种方式 使用结构体指针的指向操作符->    结构体指针->成员名
//
//	return 0;
//}





//表达式求值 
//表达式求值的顺序一部份是由操作符的优先级和结合性决定，同样有些表达式的操作数在求值过程中可能需要转换位其他类型


//隐式类型转换 
// 
// 1.整型提升
//int main()
//{
//	char a = 3;//3的二进制00000000000000000000000000000011  因为a只能放一个字节 所以此时发生截断 a中只存入了00000011
//	char b = 127;//127的二进制00000000000000000000000001111111  同理b中放入01111111
//	char c = a + b;//a和b的相加方式：因为a和b都是char类型 没有达到一个整型的大小 为了保证计算精度此时要进行整型提升 
//	//整型提升是按照变量的数据类型的符号位来提升的  因为a和b都是char类型 所以认为八位二进制的最左边那一位为符号位 所以补上0直到32位
//	//a提升后为0000000000000000000000000000011  b提示后为00000000000000000000000001111111
//    //    和为00000000000000000000000010000010
//	//因为c是char所以再次截断 取后八位10000010 
//	printf("%d\n", c);
//	//要将c以整型打出 所以这里要进行整型提升 这里就要补1了  提升后c为11111111111111111111111110000010 但这里还是补码 还需转化为原码 打印出的是原码
//	//11111111111111111111111110000001 c的反码     （注意：原码转化为反码是符号位不变 其他位取反）
//	//10000000000000000000000001111110 c的原码  转化为十进制就是126 所以打印出-126
//	return 0;
//}//对于无符号数 整型提升时就直接补0




//整型提升的示例
//int main()
//{
//	char a = 0xb6;//0x表示十六进制 b=11 二进制为1011 6的二进制为0110 所以0xb6=10110110 
//	short b = 0xb600;
//	int c = 0xb6000000;
//	if (a == 0xb6)//比较也是一种运算 所以这里a会进行整型提升 前面会补上1 所以不相等
//		printf("a");
//	if (b == 0xb600)//同理
//		printf("b");
//	if (c == 0xb6000000)
//		printf("c");
//	return 0;
//}


//int main()
//{
//	char c = 1;
//	printf("%u\n", sizeof(c));//1 c中只有一个字符 所以这里是1没有问题   
//	printf("%u\n", sizeof(+c));//4  +c 表示进行运算 所以要整型提升 所以是四个字节
//	printf("%u\n", sizeof(!c));//1
//	return 0;
//}


//2.算术转换
//如果某个1操作符的各个操作数属于不同的类型 那么除非一个操作数转化为另一个操作数的类型 否则操作无法进行
//long double  
//double
//float
//unsigned long int
//long int
//unsigned int
//int 
//会将小的类型转化为大的类型进行计算
//注意：可能会出现精度丢失 如 float f=3.14  int num=f



//操作符的属性
//1.操作符的优先级
//int main()
//{
//	int a = 10;
//	int b = 20;
//	int c = b + a * 3;//这里的*的优先级比+更高
//	return 0;
//}
//2.操作符的结合性 有L-R R-L 分别为从左向右结合 从右向左结合  比如c=a+b+3 加号的结合性是L-R 所以从左向右算


//3.是否控制求值顺序 
// 比如 &&逻辑与  从左边开始 遇到0就不再计算
// ||逻辑或 从左边开始遇到1就不再计算后面  
// ?:条件操作符（用法示例rexp1? rexp2:rexp3 比如之前的 a>b? 3:-3 就是使用了条件操作符 如果a>b为真 就只计算表达式2 不计算表达式3）
//  逗号表达式 L-R  从左到右计算 但结果只取最后一个表达式的


//比如 a*b+c*d+e*f 的计算顺序可能是 
// a*b 
// c*d 
// a*b+c*d 
// e*f 
// a*b+c*d+e*f
//意思就是 只能保证相邻的操作符先计算优先级高的 这里不能保证第三个*比第一个+更早执行
//无法确定这个算式 计算机在计算时的计算路径 所以这个算式其实是有问题的 在一些情况下他的结果可能不同 要尽量避免写出这样的式子


//再比如 表达式c+ --c  由优先级可知先计算--c 在求和 但不知道左边的c是在--c之前取值 还是在--c之后取值 取得的c的值可能会有不同 其结果也是不可预测的



////非法表达式
//int main()
//{
//	int i = 1;
//	i = i-- - --i * (i = -3) * i++ + ++i;
//	printf("%d", i);//在不同编译器上的结果居然会不同   
//	return 0;
//}



//再次举例
//int fun()
//{
//	static int count = 1;
//	return ++count;
//}
//
//int main()
//{
//	int answer;
//	answer = fun() - fun() * fun();//不能确定fun（）的调用顺序 所以结果无法确定 这样的代码是有问题的
//	return 0;
//}

//int main()
//{
//	int i = 1;
//	int a = (++i) + (++i) + (++i);//第一个+执行的时候 第三个++是否执行是不确定的
//	printf("%d\n", a);//经过测试 发现在Linux系统中执行 结果是10 所以这个代码的结果也是无法确定的
//	return 0;
//}




//在写代码时要注意 要写通过操作符的优先级和结合性就能确定唯一计算路径的代码 避免写出无法确定的 

