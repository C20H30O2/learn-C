#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include<string.h>//使strlen可以运行
#include<Windows.h>
#include<stdlib.h>


//c语言类型
// 1.内置类型有 char short int long float double  
//int main()
//{
//	int a = 10;
//	float b = 10.0;//在调试中调出内存面板 分别输入&a &b 发现&a中a的存储形式是0a 00 00 00 这是十六进制 a=10 
//	               //而b的存储形式是 00 00 20 41 由此我们可以知道 不同数据类型 存储的方式是不一样的
//
//	return 0;
//}



//2.自定义类型（构造类型）
//这里不做演示






//类型的基本归类

//整型家族  unsigned 指无符号数
//char   char类型中对于像/这样的符号 存储的是他的阿斯克码值
// unsigned char  00000000  无符号位 能表示的范围0――255
// signed char    00000000  第一位是符号位  -128――127

//short
// unsigned short 
// signed char

//int 
// unsigned int
// signed int

//long
// unsigned long
// signed long


//浮点型家族
//float
//double


//构造类型
//数组类型
//结构体类型 struct
//枚举类型 enum
//联合类型  union


//指针类型
//int*
//char*
//float*
//void*  该指针用法比较特殊 之后再介绍


//空类型
//通常应用于函数的返回类型 函数的参数 指针类型





//原码，反码，补码   
//计算机中的整数有三种表达方法 即原码反码补码   其存在的意义在于――cpu只有加法器 使用补码存储 可以方便计算 减法等算法
//其中对于无符号数和正数 他们的原码反码补码相同
//有符号数的第一位是符号位 0表示正 1表示负数

//int main()
//{
//	int a = 20;
//	//00000000000000000000000000010100原码 反码 补码
//	int b = -10;
//	//10000000000000000000000000001010 原码
//	//11111111111111111111111111110101 反码
//	//11111111111111111111111111110110 补码
//	//b的补码的十六进制表示是 0xFFFFFFF6 
//
//
//
//	//计算机计算1-1
//	//1-1=1+（-1）
//	//1的补码 00000000000000000000000000001
////-1的补码    11111111111111111111111111111
//	//和     100000000000000000000000000000 取后32位 就是0 
//
//
//
//	//大端存储模式  指数据的低位保存在内存的高地址中 而数据的高位保存在内存的低地址中
//	//小端存储模式          高              高               低              低
//	//在调试中调出内存界面 发现&a 14 00 00 00和&b f6 ff ff ff   而a的十六进制实际上是00 00 00 14 b的十六进制是ff ff ff f6  可以看出vs用的是小端存储
//	return 0;//                   低地址   高地  低       高
//}






//写代码直接告诉我们当前机器的字节序
//int main()
//{
//	int a = 1;           
//	char* p = (char*)&a; //将a的地址从int* 强制转化为 char*  代码才能正常运行 
//	if (*p == 1)//a在内存中存储为01 00 00 00  char* p 每次只能访问一个字节 如果是小端存储那么第一个访问到的就是01
//	{
//		printf("小端存储\n");
//	}
//	else
//	{
//		printf("大端存储\n");
//	}
//
//	return 0;
//}






//更加高效的写法
//int check_keys()
//{
//	int a = 1;
//	return *(char*)&a;
//}
//
//int main()
//{
//	int b = check_keys();
//	if (b == 0)
//	{
//		printf("大端存储");
//	}
//	else
//	{
//		printf("小端存储");
//	}
//	return 0;
//}





//输出什么
//int main()
//{
//	char a = -1;
//	//-1 的原码 10000000000000000000000000000001
//	//  反码    11111111111111111111111111111110
//	//    补码  11111111111111111111111111111111
//	//存入char a中的 11111111 这里发生了截断 
//	//以int打印时 发生整型提升  前面补上符号位1  11111111111111111111111111111111  再转换成原码后打印出来仍然是-1
//	signed char b = -1;
//	//同上 所以也打印出-1
//	unsigned char c = -1;
//	//因为c没有符号位所以整型提升前面补0 00000000000000000000000011111111  结果就是255
//
//	printf("a=%d,b=%d,c=%d", a, b, c);
//	return 0;
//}




//int main()
//{
//	char a = -128;
//	//-128 的原码 10000000000000000000000010000000
//	//        反码11111111111111111111111101111111
//	//        补码11111111111111111111111110000000
//	//   所以a中只存了补码的后八个比特位 10000000
//	//按符号位提升 11111111111111111111111110000000
//	printf("%u\n", a);//%d 打印十进制的有符号数字  %u打印十进制的无符号数  无符号数11111111111111111111111110000000 就是打印出来的那个数
//	return 0;
//}



//char 
//unsigned char
//signed char 
//都是八个比特位 一个字节 存储的补码 一共有2**8种
//其中char 和signed char 的第一位是符号位 所以只能表示 -128――127  -128是11111111 加一后变成0（0是00000000） 而127是01111111 加一后变成-128（即11111111）
//而unsigned char 可以表示 0――255   同样的char a=255    a+1=0


//int main()
//{
//	char a = -128;
//	printf("%u\n", a);
//
//	char b = 128;//128=127+1  而char中 127+1=-128
//	printf("%u\n", b);//所以这两个的结果相同
//
//	return 0;
//}




//int main()
//{
//	int i = -20;             //i的补码 11111111 11111111 11111111 11101100
//	unsigned int j = 10;     //j的补码 00000000 00000000 00000000 00001010
//	printf("%u\n", i + j);   //     和 11111111 11111111 11111111 11110110
//	                         //  将和转为原码100000000 00000000 00000000 00001010  结果为-10
//	return 0;
//}



//int main()
//{
//	char a[1000];
//	int i;
//	for (i = 0; i < 1000; i++)
//	{
//		a[i] = -1 - i;//如果不考虑char a中元素为-1 ―― -999     但因为char 所以实际上a中元素 为-1到-128 到127到0  0再到-128 直到1000位
//	}
//	printf("%d\n", strlen(a));//strlen计算长度时会一直读取到0为止  所以结果不是 1000而是128+127=255
//	return 0;
//}



//int main()
//{
//	unsigned char i = 0;
//	for (i = 0; i <= 255; i++)
//	{
//		printf("hehe\n");//发现为死循环  因为i=255时 i++的结果为0 所以i能表示的数永远再0――255 所以不会停下来
//	}
//	return 0;
//}




//可以通过打开limit.h文件查看各种类型的取值上下限  也可以查看float.h看float类型的表示范围

//int main()
//{
//	int n = 9;
//	float* pfloat = (float*)&n;//float*类型・的指针也能一次访问四个字节
//	printf("n=%d\n", n);//9 
//	printf("*pfloat=%f\n", *pfloat);//以f打印，保留六位小数 0.000000  说明用浮点型取出整型会有问题
//
//
//
//	*pfloat = 9.0;//存入一个浮点数
//	printf("n=%d\n", n);//1091567616  说明用整型取出浮点型会有问题
//
//
//
//	printf("*pfloat=%f\n", *pfloat);//9.000000
//	return 0;
//}

//n = 9
//* pfloat = 0.000000
//n = 1091567616
//* pfloat = 9.000000
//说明整型和浮点型的存储方式有所不同 之后再深入了解






//浮点型在内存中的存储
//float double


//根据国际标准IEEE754  任意一个二进制浮点数V可以表示为下面的形式
// (-1)^S*M*2^E
// (-1)^S 表示符号位  当S=0，V为正数；当S=1，V为负数
// M表示有效数字 大于等于1且小于等于2



//例如 9.0的存储
//先分别将小数点两边转化成二进制形式 就是 1001.0
//1001.0=(-1)^0*1.001*2^3    
// 确定了 S=0 M=1.001  E=3


//再举例比如0.5
//0.5的二进制形式是 0.1   一定要注意小数点后的二进制位 第n位表示2的-n次方  所以二进制0.1就是1*2^（-1） 就是0.5
//二进制0.1的科学计数法表示为 1.0*2^(-1)   注意：为了确保有效数字大于等于1小于2  这里小数点要向右移动 移动了一位 所以2^(-1)
//所以对于0.5  将其表示为 (-1)^0*1.0*2^(-1)   从这里我们知道E可能是负数
//但是根据规定 我们是将E以一个无符号数存入的 比如对于32位的浮点数 E只能表示0――255  因此我们会先给E加上一个中间数（不管E是正数还是负数都要加） 如果是32位 先给E加上127
//所以对于0.5 E=-1 但实际上存入的是-1+127=126的二进制形式  取出后只要减去126就得到了真正的E
//对于64位浮点数 这个中间数是1023 



// 规定对于32位的浮点数，最高位仍然是符号位，就是S    紧接着的8位是指数E  剩下的23位为有效数字M
//         64                                                 11                52 
//由于有效数字M总能表示为一点几的形式 那么就规定存储时只存储小数点后的数字  




//int main()
//{//举一个简单的例子
//	float f = 5.5;
//	//5.5的二进制表示  为101.1     (-1)^0*1.011*2^2  S=0 M=1.011 E=2
//	//存储M的部分要存入011  存储E的部分要存入2+127=129的二进制形式10000001
//	// 存入的样子 0 10000001 01100000000000000000000  
//	//    其十六进制为0x40b00000  因为是小段存储 所以在内存界面&f查看到的是 00 00 b0 40
//	return 0;
//}




//介绍完存储 接下来就是取出 取出涉及到一些特殊情况

//1 E不全为0或者不全为1时 将取到的E减去中间值就得到了E的真实值


//2 E全为0时  E=0-127=-127 或E=0-1023=-1023  得到的浮点数非常小，接近于0  
//所以这时直接规定E=1-127=-126 或E=1-1023=-1022  而M取出后也不要再补上1了 直接取小数点之后的部分  
//比如对于0 00000000 01100000000000000000000   还原后就是(-1)^0*0.011*2^(-126)


//3 E全为1时 E=255-127=128  此时还原出的数字将是一个很大的数字   这里就不再举例，不作讨论了  这里就不再深入研究了

  


//再次讨论该问题
//int main()
//{
//	int n = 9;
//
//	float* pfloat = (float*)&n;//float*类型・的指针也能一次访问四个字节
//	printf("n=%d\n", n);//9 
//	printf("*pfloat=%f\n", *pfloat);//以f打印，保留六位小数 0.000000  说明用浮点型取出整型会有问题
////	//0 00000000 00000000000000000001001    所以浮点数读取就是0.00000000000000000001001*2^(-126)     所以打印结果就是0.000000  
//
//
//	*pfloat = 9.0;//存入一个浮点数   此时就以浮点数的形式存入了9.0   (-1)^0*1.001*2^(3)  3+127=130 130的二进制为10000010 
//	//                                                    所以存入的是   0 10000010 00100000000000000000000   
//	
//	printf("n=%d\n", n);//1091567616  说明用整型取出浮点型会有问题
//	//0 10000010 00100000000000000000000 直接看作整型输出 就是1091567616
//
//	printf("*pfloat=%f\n", *pfloat);//9.000000
//	return 0;
//}





